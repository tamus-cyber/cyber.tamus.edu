"use strict";(self.webpackChunkstandards_cyber_tamus_edu=self.webpackChunkstandards_cyber_tamus_edu||[]).push([[1153],{29756:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=t(74848),s=t(28453);const o={custom_edit_url:"https://github.com/tamus-cyber/standards.cyber.tamus.edu/tree/main/static/content/tamus.edu/TAMUS_profile.xml",toc_min_heading_level:2,toc_max_heading_level:2,title:"SC-3 Security Function Isolation",description:""},c="SC-3 Security Function Isolation {#sc-03}",r={id:"catalog/sc/sc-03",title:"SC-3 Security Function Isolation",description:"",source:"@site/docs/catalog/sc/sc-03.md",sourceDirName:"catalog/sc",slug:"/catalog/sc/sc-03",permalink:"/catalog/sc/sc-03",draft:!1,unlisted:!1,editUrl:"https://github.com/tamus-cyber/standards.cyber.tamus.edu/tree/main/static/content/tamus.edu/TAMUS_profile.xml",tags:[],version:"current",frontMatter:{custom_edit_url:"https://github.com/tamus-cyber/standards.cyber.tamus.edu/tree/main/static/content/tamus.edu/TAMUS_profile.xml",toc_min_heading_level:2,toc_max_heading_level:2,title:"SC-3 Security Function Isolation",description:""},sidebar:"catalogSidebar",previous:{title:"SC-2 Separation of System and User Functionality",permalink:"/catalog/sc/sc-02"},next:{title:"SC-4 Information in Shared System Resources",permalink:"/catalog/sc/sc-04"}},a={},l=[{value:"Control",id:"control",level:3},{value:"SC-3(1) Hardware Separation",id:"sc-03.01",level:2},{value:"Control",id:"control-1",level:3},{value:"SC-3(2) Access and Flow Control Functions",id:"sc-03.02",level:2},{value:"Control",id:"control-2",level:3},{value:"SC-3(3) Minimize Nonsecurity Functionality",id:"sc-03.03",level:2},{value:"Control",id:"control-3",level:3},{value:"SC-3(4) Module Coupling and Cohesiveness",id:"sc-03.04",level:2},{value:"Control",id:"control-4",level:3},{value:"SC-3(5) Layered Structures",id:"sc-03.05",level:2},{value:"Control",id:"control-5",level:3}];function d(e){const n={br:"br",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"sc-03",children:"SC-3 Security Function Isolation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Implementation Level"})}),": System",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Contributes to Assurance"})}),": Yes"]}),"\n",(0,i.jsx)(n.h3,{id:"control",children:"Control"}),"\n",(0,i.jsx)(n.p,{children:"Isolate security functions from nonsecurity functions."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsxs)(n.p,{children:["Security functions are isolated from nonsecurity functions by means of an isolation boundary implemented within a system via partitions and domains. The isolation boundary controls access to and protects the integrity of the hardware, software, and firmware that perform system security functions. Systems implement code separation in many ways, such as through the provision of security kernels via processor rings or processor modes. For non-kernel code, security function isolation is often achieved through file system protections that protect the code on disk and address space protections that protect executing code. Systems can restrict access to security functions using access control mechanisms and by implementing least privilege capabilities. While the ideal is for all code within the defined security function isolation boundary to only contain security-relevant code, it is sometimes necessary to include nonsecurity functions as an exception. The isolation of security functions from nonsecurity functions can be achieved by applying the systems security engineering design principles in ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8",children:"SA-8"})," , including ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.1",children:"SA-8(1)"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.3",children:"SA-8(3)"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.4",children:"SA-8(4)"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.10",children:"SA-8(10)"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.12",children:"SA-8(12)"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.13",children:"SA-8(13)"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.14",children:"SA-8(14)"})," , and ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.18",children:"SA-8(18)"}),"."]})]}),"\n",(0,i.jsx)(n.h2,{id:"sc-03.01",children:"SC-3(1) Hardware Separation"}),"\n",(0,i.jsx)(n.h3,{id:"control-1",children:"Control"}),"\n",(0,i.jsx)(n.p,{children:"Employ hardware separation mechanisms to implement security function isolation."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(n.p,{children:"Hardware separation mechanisms include hardware ring architectures that are implemented within microprocessors and hardware-enforced address segmentation used to support logically distinct storage objects with separate attributes (i.e., readable, writeable)."})]}),"\n",(0,i.jsx)(n.h2,{id:"sc-03.02",children:"SC-3(2) Access and Flow Control Functions"}),"\n",(0,i.jsx)(n.h3,{id:"control-2",children:"Control"}),"\n",(0,i.jsx)(n.p,{children:"Isolate security functions enforcing access and information flow control from nonsecurity functions and from other security functions."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(n.p,{children:"Security function isolation occurs because of implementation. The functions can still be scanned and monitored. Security functions that are potentially isolated from access and flow control enforcement functions include auditing, intrusion detection, and malicious code protection functions."})]}),"\n",(0,i.jsx)(n.h2,{id:"sc-03.03",children:"SC-3(3) Minimize Nonsecurity Functionality"}),"\n",(0,i.jsx)(n.h3,{id:"control-3",children:"Control"}),"\n",(0,i.jsx)(n.p,{children:"Minimize the number of nonsecurity functions included within the isolation boundary containing security functions."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(n.p,{children:"Where it is not feasible to achieve strict isolation of nonsecurity functions from security functions, it is necessary to take actions to minimize nonsecurity-relevant functions within the security function boundary. Nonsecurity functions contained within the isolation boundary are considered security-relevant because errors or malicious code in the software can directly impact the security functions of systems. The fundamental design objective is that the specific portions of systems that provide information security are of minimal size and complexity. Minimizing the number of nonsecurity functions in the security-relevant system components allows designers and implementers to focus only on those functions which are necessary to provide the desired security capability (typically access enforcement). By minimizing the nonsecurity functions within the isolation boundaries, the amount of code that is trusted to enforce security policies is significantly reduced, thus contributing to understandability."})]}),"\n",(0,i.jsx)(n.h2,{id:"sc-03.04",children:"SC-3(4) Module Coupling and Cohesiveness"}),"\n",(0,i.jsx)(n.h3,{id:"control-4",children:"Control"}),"\n",(0,i.jsx)(n.p,{children:"Implement security functions as largely independent modules that maximize internal cohesiveness within modules and minimize coupling between modules."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(n.p,{children:"The reduction of inter-module interactions helps to constrain security functions and manage complexity. The concepts of coupling and cohesion are important with respect to modularity in software design. Coupling refers to the dependencies that one module has on other modules. Cohesion refers to the relationship between functions within a module. Best practices in software engineering and systems security engineering rely on layering, minimization, and modular decomposition to reduce and manage complexity. This produces software modules that are highly cohesive and loosely coupled."})]}),"\n",(0,i.jsx)(n.h2,{id:"sc-03.05",children:"SC-3(5) Layered Structures"}),"\n",(0,i.jsx)(n.h3,{id:"control-5",children:"Control"}),"\n",(0,i.jsx)(n.p,{children:"Implement security functions as a layered structure minimizing interactions between layers of the design and avoiding any dependence by lower layers on the functionality or correctness of higher layers."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(n.p,{children:"The implementation of layered structures with minimized interactions among security functions and non-looping layers (i.e., lower-layer functions do not depend on higher-layer functions) enables the isolation of security functions and the management of complexity."})]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);