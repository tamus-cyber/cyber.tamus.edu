"use strict";(self.webpackChunkstandards_cyber_tamus_edu=self.webpackChunkstandards_cyber_tamus_edu||[]).push([[2360],{36541:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=n(74848),r=n(28453);const s={custom_edit_url:"https://github.com/tamus-cyber/standards.cyber.tamus.edu/tree/main/static/content/tamus.edu/TAMUS_profile.xml",toc_min_heading_level:2,toc_max_heading_level:2,title:"SA-17 Developer Security and Privacy Architecture and Design",description:""},a="SA-17 Developer Security and Privacy Architecture and Design {#sa-17}",o={id:"catalog/sa/sa-17",title:"SA-17 Developer Security and Privacy Architecture and Design",description:"",source:"@site/docs/catalog/sa/sa-17.md",sourceDirName:"catalog/sa",slug:"/catalog/sa/sa-17",permalink:"/catalog/sa/sa-17",draft:!1,unlisted:!1,editUrl:"https://github.com/tamus-cyber/standards.cyber.tamus.edu/tree/main/static/content/tamus.edu/TAMUS_profile.xml",tags:[],version:"current",frontMatter:{custom_edit_url:"https://github.com/tamus-cyber/standards.cyber.tamus.edu/tree/main/static/content/tamus.edu/TAMUS_profile.xml",toc_min_heading_level:2,toc_max_heading_level:2,title:"SA-17 Developer Security and Privacy Architecture and Design",description:""},sidebar:"catalogSidebar",previous:{title:"SA-16 Developer-provided Training",permalink:"/catalog/sa/sa-16"},next:{title:"SA-18 Tamper Resistance and Detection",permalink:"/catalog/sa/sa-18"}},c={},l=[{value:"Control",id:"control",level:3},{value:"SA-17(1) Formal Policy Model",id:"sa-17.01",level:2},{value:"Control",id:"control-1",level:3},{value:"SA-17(2) Security-relevant Components",id:"sa-17.02",level:2},{value:"Control",id:"control-2",level:3},{value:"SA-17(3) Formal Correspondence",id:"sa-17.03",level:2},{value:"Control",id:"control-3",level:3},{value:"SA-17(4) Informal Correspondence",id:"sa-17.04",level:2},{value:"Control",id:"control-4",level:3},{value:"SA-17(5) Conceptually Simple Design",id:"sa-17.05",level:2},{value:"Control",id:"control-5",level:3},{value:"SA-17(6) Structure for Testing",id:"sa-17.06",level:2},{value:"Control",id:"control-6",level:3},{value:"SA-17(7) Structure for Least Privilege",id:"sa-17.07",level:2},{value:"Control",id:"control-7",level:3},{value:"SA-17(8) Orchestration",id:"sa-17.08",level:2},{value:"Control",id:"control-8",level:3},{value:"SA-17(9) Design Diversity",id:"sa-17.09",level:2},{value:"Control",id:"control-9",level:3}];function d(e){const t={br:"br",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,r.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"sa-17",children:"SA-17 Developer Security and Privacy Architecture and Design"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:(0,i.jsx)(t.strong,{children:"Implementation Level"})}),": Organization",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.strong,{children:"Contributes to Assurance"})}),": Yes"]}),"\n",(0,i.jsx)(t.h3,{id:"control",children:"Control"}),"\n",(0,i.jsx)(t.p,{children:"a. Is consistent with the organization\u2019s security and privacy architecture that is an integral part the organization\u2019s enterprise architecture;"}),"\n",(0,i.jsx)(t.p,{children:"b. Accurately and completely describes the required security and privacy functionality, and the allocation of controls among physical and logical components; and"}),"\n",(0,i.jsx)(t.p,{children:"c. Expresses how individual security and privacy functions, mechanisms, and services work together to provide required security and privacy capabilities and a unified approach to protection."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsxs)(t.p,{children:["Developer security and privacy architecture and design are directed at external developers, although they could also be applied to internal (in-house) development. In contrast, ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#pl-8",children:"PL-8"})," is directed at internal developers to ensure that organizations develop a security and privacy architecture that is integrated with the enterprise architecture. The distinction between SA-17 and ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#pl-8",children:"PL-8"})," is especially important when organizations outsource the development of systems, system components, or system services and when there is a requirement to demonstrate consistency with the enterprise architecture and security and privacy architecture of the organization. ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#87087451-2af5-43d4-88c1-d66ad850f614",children:"ISO 15408-2"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#4452efc0-e79e-47b8-aa30-b54f3ef61c2f",children:"ISO 15408-3"})," , and ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#e3cc0520-a366-4fc9-abc2-5272db7e3564",children:"SP 800-160-1"})," provide information on security architecture and design, including formal policy models, security-relevant components, formal and informal correspondence, conceptually simple design, and structuring for least privilege and testing."]})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.01",children:"SA-17(1) Formal Policy Model"}),"\n",(0,i.jsx)(t.h3,{id:"control-1",children:"Control"}),"\n",(0,i.jsxs)(t.p,{children:["(a) Produce, as an integral part of the development process, a formal policy model describing the ",(0,i.jsxs)("strong",{children:["                        ",(0,i.jsx)("em",{children:"[Assignment: organization-defined elements of organizational security and privacy policy]"}),"                     "]})," to be enforced; and"]}),"\n",(0,i.jsx)(t.p,{children:"(b) Prove that the formal policy model is internally consistent and sufficient to enforce the defined elements of the organizational security and privacy policy when implemented."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(t.p,{children:"Formal models describe specific behaviors or security and privacy policies using formal languages, thus enabling the correctness of those behaviors and policies to be formally proven. Not all components of systems can be modeled. Generally, formal specifications are scoped to the behaviors or policies of interest, such as nondiscretionary access control policies. Organizations choose the formal modeling language and approach based on the nature of the behaviors and policies to be described and the available tools."})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.02",children:"SA-17(2) Security-relevant Components"}),"\n",(0,i.jsx)(t.h3,{id:"control-2",children:"Control"}),"\n",(0,i.jsx)(t.p,{children:"(a) Define security-relevant hardware, software, and firmware; and"}),"\n",(0,i.jsx)(t.p,{children:"(b) Provide a rationale that the definition for security-relevant hardware, software, and firmware is complete."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(t.p,{children:"The security-relevant hardware, software, and firmware represent the portion of the system, component, or service that is trusted to perform correctly to maintain required security properties."})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.03",children:"SA-17(3) Formal Correspondence"}),"\n",(0,i.jsx)(t.h3,{id:"control-3",children:"Control"}),"\n",(0,i.jsx)(t.p,{children:"(a) Produce, as an integral part of the development process, a formal top-level specification that specifies the interfaces to security-relevant hardware, software, and firmware in terms of exceptions, error messages, and effects;"}),"\n",(0,i.jsx)(t.p,{children:"(b) Show via proof to the extent feasible with additional informal demonstration as necessary, that the formal top-level specification is consistent with the formal policy model;"}),"\n",(0,i.jsx)(t.p,{children:"(c) Show via informal demonstration, that the formal top-level specification completely covers the interfaces to security-relevant hardware, software, and firmware;"}),"\n",(0,i.jsx)(t.p,{children:"(d) Show that the formal top-level specification is an accurate description of the implemented security-relevant hardware, software, and firmware; and"}),"\n",(0,i.jsx)(t.p,{children:"(e) Describe the security-relevant hardware, software, and firmware mechanisms not addressed in the formal top-level specification but strictly internal to the security-relevant hardware, software, and firmware."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(t.p,{children:"Correspondence is an important part of the assurance gained through modeling. It demonstrates that the implementation is an accurate transformation of the model, and that any additional code or implementation details that are present have no impact on the behaviors or policies being modeled. Formal methods can be used to show that the high-level security properties are satisfied by the formal system description, and that the formal system description is correctly implemented by a description of some lower level, including a hardware description. Consistency between the formal top-level specification and the formal policy models is generally not amenable to being fully proven. Therefore, a combination of formal and informal methods may be needed to demonstrate such consistency. Consistency between the formal top-level specification and the actual implementation may require the use of an informal demonstration due to limitations on the applicability of formal methods to prove that the specification accurately reflects the implementation. Hardware, software, and firmware mechanisms internal to security-relevant components include mapping registers and direct memory input and output."})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.04",children:"SA-17(4) Informal Correspondence"}),"\n",(0,i.jsx)(t.h3,{id:"control-4",children:"Control"}),"\n",(0,i.jsx)(t.p,{children:"(a) Produce, as an integral part of the development process, an informal descriptive top-level specification that specifies the interfaces to security-relevant hardware, software, and firmware in terms of exceptions, error messages, and effects;"}),"\n",(0,i.jsxs)(t.p,{children:["(b) Show via ",(0,i.jsxs)("strong",{children:["                        ",(0,i.jsx)("em",{children:"[Selection: informal demonstration, convincing argument with formal methods as feasible]"}),"                     "]})," that the descriptive top-level specification is consistent with the formal policy model;"]}),"\n",(0,i.jsx)(t.p,{children:"(c) Show via informal demonstration, that the descriptive top-level specification completely covers the interfaces to security-relevant hardware, software, and firmware;"}),"\n",(0,i.jsx)(t.p,{children:"(d) Show that the descriptive top-level specification is an accurate description of the interfaces to security-relevant hardware, software, and firmware; and"}),"\n",(0,i.jsx)(t.p,{children:"(e) Describe the security-relevant hardware, software, and firmware mechanisms not addressed in the descriptive top-level specification but strictly internal to the security-relevant hardware, software, and firmware."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(t.p,{children:"Correspondence is an important part of the assurance gained through modeling. It demonstrates that the implementation is an accurate transformation of the model, and that additional code or implementation detail has no impact on the behaviors or policies being modeled. Consistency between the descriptive top-level specification (i.e., high-level/low-level design) and the formal policy model is generally not amenable to being fully proven. Therefore, a combination of formal and informal methods may be needed to show such consistency. Hardware, software, and firmware mechanisms strictly internal to security-relevant hardware, software, and firmware include mapping registers and direct memory input and output."})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.05",children:"SA-17(5) Conceptually Simple Design"}),"\n",(0,i.jsx)(t.h3,{id:"control-5",children:"Control"}),"\n",(0,i.jsx)(t.p,{children:"(a) Design and structure the security-relevant hardware, software, and firmware to use a complete, conceptually simple protection mechanism with precisely defined semantics; and"}),"\n",(0,i.jsx)(t.p,{children:"(b) Internally structure the security-relevant hardware, software, and firmware with specific regard for this mechanism."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsxs)(t.p,{children:["The principle of reduced complexity states that the system design is as simple and small as possible (see ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.7",children:"SA-8(7)"})," ). A small and simple design is easier to understand and analyze and is also less prone to error (see ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#ac-25",children:"AC-25"}),", ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.13",children:"SA-8(13)"})," ). The principle of reduced complexity applies to any aspect of a system, but it has particular importance for security due to the various analyses performed to obtain evidence about the emergent security property of the system. For such analyses to be successful, a small and simple design is essential. Application of the principle of reduced complexity contributes to the ability of system developers to understand the correctness and completeness of system security functions and facilitates the identification of potential vulnerabilities. The corollary of reduced complexity states that the simplicity of the system is directly related to the number of vulnerabilities it will contain. That is, simpler systems contain fewer vulnerabilities. An important benefit of reduced complexity is that it is easier to understand whether the security policy has been captured in the system design and that fewer vulnerabilities are likely to be introduced during engineering development. An additional benefit is that any such conclusion about correctness, completeness, and existence of vulnerabilities can be reached with a higher degree of assurance in contrast to conclusions reached in situations where the system design is inherently more complex."]})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.06",children:"SA-17(6) Structure for Testing"}),"\n",(0,i.jsx)(t.h3,{id:"control-6",children:"Control"}),"\n",(0,i.jsx)(t.p,{children:"Require the developer of the system, system component, or system service to structure security-relevant hardware, software, and firmware to facilitate testing."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsxs)(t.p,{children:["Applying the security design principles in ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#e3cc0520-a366-4fc9-abc2-5272db7e3564",children:"SP 800-160-1"})," promotes complete, consistent, and comprehensive testing and evaluation of systems, system components, and services. The thoroughness of such testing contributes to the evidence produced to generate an effective assurance case or argument as to the trustworthiness of the system, system component, or service."]})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.07",children:"SA-17(7) Structure for Least Privilege"}),"\n",(0,i.jsx)(t.h3,{id:"control-7",children:"Control"}),"\n",(0,i.jsx)(t.p,{children:"Require the developer of the system, system component, or system service to structure security-relevant hardware, software, and firmware to facilitate controlling access with least privilege."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsxs)(t.p,{children:["The principle of least privilege states that each component is allocated sufficient privileges to accomplish its specified functions but no more (see ",(0,i.jsx)("a",{xmlns:"http://csrc.nist.gov/ns/oscal/1.0",href:"#sa-8.14",children:"SA-8(14)"})," ). Applying the principle of least privilege limits the scope of the component\u2019s actions, which has two desirable effects. First, the security impact of a failure, corruption, or misuse of the system component results in a minimized security impact. Second, the security analysis of the component is simplified. Least privilege is a pervasive principle that is reflected in all aspects of the secure system design. Interfaces used to invoke component capability are available to only certain subsets of the user population, and component design supports a sufficiently fine granularity of privilege decomposition. For example, in the case of an audit mechanism, there may be an interface for the audit manager, who configures the audit settings; an interface for the audit operator, who ensures that audit data is safely collected and stored; and, finally, yet another interface for the audit reviewer, who only has a need to view the audit data that has been collected but no need to perform operations on that data."]})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.08",children:"SA-17(8) Orchestration"}),"\n",(0,i.jsx)(t.h3,{id:"control-8",children:"Control"}),"\n",(0,i.jsxs)(t.p,{children:["Design ",(0,i.jsxs)("strong",{children:["                     ",(0,i.jsx)("em",{children:"[Assignment: critical systems]"}),"                  "]})," with coordinated behavior to implement the following capabilities: ",(0,i.jsxs)("strong",{children:["                     ",(0,i.jsx)("em",{children:"[Assignment: capabilities]"}),"                  "]}),"."]}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(t.p,{children:"Security resources that are distributed, located at different layers or in different system elements, or are implemented to support different aspects of trustworthiness can interact in unforeseen or incorrect ways. Adverse consequences can include cascading failures, interference, or coverage gaps. Coordination of the behavior of security resources (e.g., by ensuring that one patch is installed across all resources before making a configuration change that assumes that the patch is propagated) can avert such negative interactions."})]}),"\n",(0,i.jsx)(t.h2,{id:"sa-17.09",children:"SA-17(9) Design Diversity"}),"\n",(0,i.jsx)(t.h3,{id:"control-9",children:"Control"}),"\n",(0,i.jsxs)(t.p,{children:["Use different designs for ",(0,i.jsxs)("strong",{children:["                     ",(0,i.jsx)("em",{children:"[Assignment: critical systems]"}),"                  "]})," to satisfy a common set of requirements or to provide equivalent functionality."]}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Supplemental Guidance"}),(0,i.jsx)(t.p,{children:"Design diversity is achieved by supplying the same requirements specification to multiple developers, each of whom is responsible for developing a variant of the system or system component that meets the requirements. Variants can be in software design, in hardware design, or in both hardware and a software design. Differences in the designs of the variants can result from developer experience (e.g., prior use of a design pattern), design style (e.g., when decomposing a required function into smaller tasks, determining what constitutes a separate task and how far to decompose tasks into sub-tasks), selection of libraries to incorporate into the variant, and the development environment (e.g., different design tools make some design patterns easier to visualize). Hardware design diversity includes making different decisions about what information to keep in analog form and what information to convert to digital form, transmitting the same information at different times, and introducing delays in sampling (temporal diversity). Design diversity is commonly used to support fault tolerance."})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(96540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);